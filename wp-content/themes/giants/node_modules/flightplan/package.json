{
  "name": "flightplan",
  "description": "Library for streamlining application deployment or systems administration tasks",
  "version": "0.4.0",
  "author": {
    "name": "Patrick Stadler",
    "email": "patrick.stadler@gmail.com"
  },
  "keywords": [
    "deploy",
    "deployment",
    "commands",
    "devops",
    "exec",
    "shell",
    "ssh",
    "task",
    "parallel",
    "sequential",
    "remote",
    "local",
    "fabric"
  ],
  "readmeFilename": "README.md",
  "homepage": "https://github.com/pstadler/flightplan",
  "repository": {
    "type": "git",
    "url": "https://github.com/pstadler/flightplan"
  },
  "bugs": {
    "url": "https://github.com/pstadler/flightplan/issues"
  },
  "bin": {
    "fly": "./bin/fly.js"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "dependencies": {
    "fibers": "~1.0.1",
    "ssh2": "~0.2.17",
    "colors": "~0.6.2",
    "commander": "~2.1.0",
    "prompt": "~0.2.12",
    "pretty-hrtime": "~0.2.1",
    "coffee-script": "~1.7.1"
  },
  "optionalDependencies": {
    "coffee-script": "~1.7.1"
  },
  "devDependencies": {
    "gulp": "~3.5.2",
    "gulp-jshint": "~1.4.2",
    "jshint-stylish": "~0.1.5",
    "markdox": "~0.1.2"
  },
  "license": "MIT",
  "readme": "# Flightplan ✈ [![NPM version][npm-image]][npm-url]\n\nRun a sequence of commands against local and remote hosts.\n\nFlightplan is a [node.js](http://nodejs.org) library for streamlining application deployment or systems administration tasks, similar to Python's [Fabric](http://fabfile.org).\n\n## Installation & Usage\n\n```bash\n# install the cli tool\n$ npm install -g flightplan\n\n# use it in your project\n$ npm install flightplan --save-dev\n\n# run a flightplan (`fly --help` for more information)\n$ fly [task:]<destination> [--plan flightplan.(js|coffee)]\n```\n\nBy default, the `fly` command will look for `flightplan.js` or `flightplan.coffee`.\n\nIf you do not install the Flightplan module locally to your project (i.e. to support non-javascript projects) then make sure the global `node_modules` is in your Node.js path. For example:\n\n```bash\n$ export NODE_PATH=/usr/local/lib/node_modules\n$ fly <destination>\n```\n\n## Sample flightplan.js\n\n```javascript\n// flightplan.js\nvar Flightplan = require('flightplan');\n\nvar tmpDir = 'pstadler-sh-' + new Date().getTime();\n\nvar plan = new Flightplan();\n\n// configuration\nplan.briefing({\n  debug: false,\n  destinations: {\n    'staging': {\n      host: 'staging.pstadler.sh',\n      username: 'pstadler',\n      agent: process.env.SSH_AUTH_SOCK\n    },\n    'production': [\n      {\n        host: 'www1.pstadler.sh',\n        username: 'pstadler',\n        agent: process.env.SSH_AUTH_SOCK\n      },\n      {\n        host: 'www2.pstadler.sh',\n        username: 'pstadler',\n        agent: process.env.SSH_AUTH_SOCK\n      }\n    ]\n  }\n});\n\n// run commands on localhost\nplan.local(function(local) {\n  local.log('Run build');\n  local.exec('gulp build');\n\n  local.log('Copy files to remote hosts');\n  var filesToCopy = local.exec('git ls-files', {silent: true});\n  // rsync files to all the destination's hosts\n  local.transfer(filesToCopy, '/tmp/' + tmpDir);\n});\n\n// run commands on remote hosts (destinations)\nplan.remote(function(remote) {\n  remote.log('Move folder to web root');\n  remote.sudo('cp -R /tmp/' + tmpDir + ' ~', {user: 'www'});\n  remote.rm('-rf /tmp/' + tmpDir);\n\n  remote.log('Install dependencies');\n  remote.sudo('npm --production --prefix ~/' + tmpDir\n                            + ' install ~/' + tmpDir, {user: 'www'});\n\n  remote.log('Reload application');\n  remote.sudo('ln -snf ~/' + tmpDir + ' ~/pstadler-sh', {user: 'www'});\n  remote.sudo('pm2 reload pstadler-sh', {user: 'www'});\n});\n\n// run more commands on localhost afterwards\nplan.local(function(local) { /* ... */ });\n// ...or on remote hosts\nplan.remote(function(remote) { /* ... */ });\n\n// executed if flightplan succeeded\nplan.success(function() { /* ... */ });\n\n// executed if flightplan failed\nplan.disaster(function() { /* ... */ });\n\n// always executed after flightplan finished\nplan.debriefing(function() { /* ... */ });\n```\n\n# Documentation\n\n<!-- DOCS -->\n\n<!-- Start lib/flightplan.js -->\n\n## Flightplan\n\nA flightplan is a set of subsequent flights to be executed on one or more\nhosts. The constructor doesn't take any arguments. The configuration is\nhandled with the `briefing()` method.\n\n```javascript\nvar plan = new Flightplan();\n```\n\n### Flights\nA flight is a set of commands to be executed on one or more hosts. There are\ntwo types of flights:\n\n#### Local flights\n\nCommands in local flights are executed on the **localhost**.\n\n```javascript\nplan.local(function(transport) {\n  transport.hostname(); // prints the hostname of localhost\n});\n```\n\n#### Remote flights\n\nCommands in remote flights are executed in **parallel** against\nremote hosts defined during the briefing.\n\n```javascript\nplan.remote(function(transport) {\n  transport.hostname(); // prints the hostname(s) of the remote host(s)\n});\n```\n\nYou can define multiple flights of each type. They will be executed in the\norder of their definition. If a previous flight failed, all subsequent\nflights won't get executed. For more information about what it means for\na flight to fail, see the section about `Transport`.\n\n```javascript\n// executed first\nplan.local(function(transport) {});\n\n// executed if first flight succeeded\nplan.remote(function(transport) {});\n\n// executed if second flight succeeded\nplan.local(function(transport) {});\n\n// ...\n```\n\n### Tasks\nFlightplan supports optional tasks to run a subset of flights.\n\n```javascript\n// fly deploy:<destination>\nplan.local('deploy', function(transport) {});\n\n// fly build:<destination>\nplan.local('build', function(transport) {});\n\n// fly deploy:<destination> or...\n// fly build:<destination>\nplan.local(['deploy', 'build'], function(transport) {});\nplan.remote(['deploy', 'build'], function(transport) {});\n```\n\nIf no task is specified it's implicitly set to \"default\". Therefore,\n`fly <destination>` is the same as `fly default:<destination>`.\n\n```javascript\n// fly <destination>\nplan.local(function(transport) {});\n// is the same as...\nplan.local('default', function(transport) {});\n// \"default\" + other tasks:\nplan.remote(['default', 'deploy', 'build'], function(transport) {});\n```\n\n### flightplan.briefing(config) → this\n\nConfigure the flightplan's destinations with `briefing()`. Without a\nproper briefing you can't do remote flights which require at\nleast one destination. Each destination consists of one ore more hosts.\n\nValues in the hosts section are passed directly to the `connect()`\nmethod of [mscdex/ssh2](https://github.com/mscdex/ssh2#connection-methods)\nwith one exception: `privateKey` needs to be passed as a string\ncontaining the path to the keyfile instead of the key itself.\n\n```javascript\nplan.briefing({\n  destinations: {\n    // run with `fly staging`\n    'staging': {\n      // see: https://github.com/mscdex/ssh2#connection-methods\n      host: 'staging.pstadler.sh',\n      username: 'pstadler',\n      agent: process.env.SSH_AUTH_SOCK\n    },\n    // run with `fly production`\n    'production': [\n      {\n        host: 'www1.pstadler.sh',\n        username: 'pstadler',\n        agent: process.env.SSH_AUTH_SOCK\n      },\n      {\n        host: 'www2.pstadler.sh',\n        username: 'pstadler',\n        agent: process.env.SSH_AUTH_SOCK\n      },\n    ]\n  }\n});\n```\n\nYou can override the `username` value of all hosts by calling `fly` with\nthe `-u|--username` option:\n\n```bash\nfly production --username=admin\n```\n\n### flightplan.local([task|tasks, ]fn) → this\n\nCalling this method registers a local flight. Local flights are\nexecuted on your localhost. When `fn` gets called a `Transport` object\nis passed with the first argument.\n\n```javascript\nplan.local(function(local) {\n  local.echo('hello from your localhost.');\n});\n```\n\nAn optional first parameter of type Array or String can be passed for\ndefining the flight's task(s).\n\n### flightplan.remote([task|tasks, ]fn) → this\n\nCalling this method registers a remote flight. Remote\nflights are executed on the current destination's remote hosts defined\nwith `briefing()`. When `fn` gets called a `Transport` object is passed\nwith the first argument.\n\n```javascript\nplan.remote(function(remote) {\n  remote.echo('hello from the remote host.');\n});\n```\n\nAn optional first parameter of type Array or String can be passed for\ndefining the flight's task(s).\n\n### flightplan.success(fn) → this\n\n`fn()` is called after the flightplan (and therefore all flights)\nsucceeded.\n\n### flightplan.disaster(fn) → this\n\n`fn()` is called after the flightplan was aborted.\n\n### flightplan.debriefing(fn)\n\n`fn()` is called at the very end of the flightplan's execution.\n\n### flightplan.isAborted() → Boolean\n\nWhether the flightplan is aborted or not.\n\n<!-- End lib/flightplan.js -->\n\n<!-- Start lib/transport/index.js -->\n\n## Transport\n\nA transport is the interface you use during flights. Basically they\noffer you a set of methods to execute a chain of commands. Depending on the\ntype of flight, this is either a `ShellTransport` object for local\nflights, or an `SSHTransport` for remote flights. Both transports\nexpose the same set of methods as described in this section.\n\n```javascript\nplan.local(function(local) {\n  local.echo('ShellTransport.echo() called');\n});\n\nplan.remote(function(remote) {\n  remote.echo('SSHTransport.echo() called');\n});\n```\n\nWe call the Transport object `transport` in the following section to avoid\nconfusion. However, do yourself a favor and use `local` for local, and\n`remote` for remote flights.\n\n#### Accessing flight-specific information\n\nFlightplan provides information during flights with the `target` properties:\n\n```javascript\nplan.remote(function(transport) { // applies to local flights as well\n  // Flightplan specific information\n  console.log(plan.target.destination); // 'production'\n  console.log(plan.target.hosts); // [{ host: 'www1.pstadler.sh', port: 22 }, ...]\n\n  // Flight specific information\n  console.log(transport.target); // { host: 'www1.pstadler.sh', port: 22 }\n});\n```\n\n### transport.exec(command[, options]) → code: int, stdout: String, stderr: String\n\nTo execute a command you have the choice between using `exec()` or one\nof the handy wrappers for often used commands:\n`transport.exec('ls -al')` is the same as `transport.ls('-al')`. If a\ncommand returns a non-zero exit code, the flightplan will be aborted and\nall subsequent commands and flights won't get executed.\n\n#### Options\nOptions can be passed as a second argument. If `failsafe: true` is\npassed, the command is allowed to fail (i.e. exiting with a non-zero\nexit code), whereas `silent: true` will simply suppress its output.\n\n```javascript\n// output of `ls -al` is suppressed\ntransport.ls('-al', {silent: true});\n\n// flightplan continues even if command fails with exit code `1`\ntransport.ls('-al foo', {failsafe: true}); // ls: foo: No such file or directory\n\n// both options together\ntransport.ls('-al foo', {silent: true, failsafe: true});\n```\n\nTo apply these options to multiple commands check out the docs of\n`transport.silent()` and `transport.failsafe()`.\n\n#### Return value\nEach command returns an object containing `code`, `stdout` and`stderr`:\n\n```javascript\nvar retval = transport.echo('Hello world');\nconsole.log(retval); // { code: 0, stdout: 'Hello world\\n', stderr: null }\n```\n\n### transport.sudo(command[, options]) → code: int, stdout: String, stderr: String\n\nExecute a command as another user with `sudo()`. It has the same\nsignature as `exec()`. Per default, the user under which the command\nwill be executed is \"root\". This can be changed by passing\n`user: \"name\"` with the second argument:\n\n```javascript\n// will run: sudo -u root -i bash -c 'Hello world'\ntransport.sudo('echo Hello world');\n\n// will run sudo -u www -i bash -c 'Hello world'\ntransport.sudo('echo Hello world', {user: 'www'});\n\n// further options passed (see `exec()`)\ntransport.sudo('echo Hello world', {user: 'www', silent: true, failsafe: true});\n```\n\nFlightplan's `sudo()` requires a certain setup on your host. In order to\nmake things work on a typical Ubuntu installation, follow these rules:\n\n```bash\n# Scenario:\n# 'pstadler' is the user for connecting to the host and 'www' is the user\n# under which you want to execute commands with sudo.\n\n# 1. 'pstadler' has to be in the sudo group:\n$ groups pstadler\npstadler : pstadler sudo\n\n# 2. 'pstadler' needs to be able to run sudo -u 'www' without a password.\n# In order to do this, add the following line to /etc/sudoers:\npstadler ALL=(www) NOPASSWD: ALL\n\n# 3. user 'www' needs to have a login shell (e.g. bash, sh, zsh, ...)\n$ cat /etc/passwd | grep www\nwww:x:1002:1002::/home/www:/bin/bash   # GOOD\nwww:x:1002:1002::/home/www:/bin/false  # BAD\n```\n\n### transport.transfer(files, remoteDir[, options]) → [results]\n\nCopy a list of files to the current destination's remote host(s) using\n`rsync` with the SSH protocol. File transfers are executed in parallel.\n After finishing all transfers, an array containing results from\n`transport.exec()` is returned. This method is only available on local\nflights.\n\n```javascript\nvar files = ['path/to/file1', 'path/to/file2'];\nlocal.transfer(files, '/tmp/foo');\n```\n\n#### Files argument\nTo make things more comfortable, the `files` argument doesn't have to be\npassed as an array. Results from previous commands and zero-terminated\nstrings are handled as well:\n\n```javascript\n// use result from a previous command\nvar files = local.git('ls-files', {silent: true}); // get list of files under version control\nlocal.transfer(files, '/tmp/foo');\n\n// use zero-terminated result from a previous command\nvar files = local.exec('(git ls-files -z;find node_modules -type f -print0)', {silent: true});\nlocal.transfer(files, '/tmp/foo');\n\n// use results from multiple commands\nvar result1 = local.git('ls-files', {silent: true}).stdout.split('\\n');\nvar result2 = local.find('node_modules -type f', {silent: true}).stdout.split('\\n');\nvar files = result1.concat(result2);\nfiles.push('path/to/another/file');\nlocal.transfer(files, '/tmp/foo');\n```\n\n`transfer()` will use the current host's username defined with\n`briefing()` unless `fly` is called with the `-u|--username` option.\nIn this case the latter will be used. If debugging is enabled\n(either with `briefing()` or with `fly --debug`), `rsync` is executed\nin verbose mode (`-v`).\n\n### transport.prompt(message[, options]) → input\n\nPrompt for user input.\n\n```javascript\nvar input = transport.prompt('Are you sure you want to continue? [yes]');\nif(input.indexOf('yes') === -1) {\n  transport.abort('user canceled flight');\n}\n\n// prompt for password (with UNIX-style hidden input)\nvar password = transport.prompt('Enter your password:', { hidden: true });\n\n// prompt when deploying to a specific destination\nif(plan.target.destination === 'production') {\n  var input = transport.prompt('Ready for deploying to production? [yes]');\n  if(input.indexOf('yes') === -1) {\n    transport.abort('user canceled flight');\n  }\n}\n```\n\n### transport.log(message)\n\nPrint a message to stdout. Flightplan takes care that the message\nis formatted correctly within the current context.\n\n```javascript\ntransport.log('Copying files to remote hosts');\n```\n\n### transport.waitFor(fn(done)) → mixed\n\nExecute a function and return after the callback `done` is called.\nThis is used for running asynchronous functions in a synchronous way.\n\nThe callback takes an optional argument which is then returned by\n`waitFor()`.\n\n```javascript\nvar result = transport.waitFor(function(done) {\n  require('node-notifier').notify({\n      message: 'Hello World'\n    }, function(err, response) {\n      done(err || 'sent!');\n    });\n});\nconsole.log(result); // 'sent!'\n```\n\n### transport.with(cmd|options[, options], fn)\n\nExecute commands with a certain context.\n\n```javascript\ntransport.with('cd /tmp', function() {\n  transport.ls('-al'); // 'cd /tmp && ls -al'\n});\n\ntransport.with({silent: true, failsafe: true}, function() {\n  transport.ls('-al'); // output suppressed, fail safely\n});\n\ntransport.with('cd /tmp', {silent: true}, function() {\n  transport.ls('-al'); // 'cd /tmp && ls -al', output suppressed\n});\n```\n\n### transport.silent()\n\nWhen calling `silent()` all subsequent commands are executed without\nprinting their output to stdout until `verbose()` is called.\n\n```javascript\ntransport.ls(); // output will be printed to stdout\ntransport.silent();\ntransport.ls(); // output won't be printed to stdout\n```\n\n### transport.verbose()\n\nCalling `verbose()` reverts the behavior introduced with `silent()`.\nOutput of commands will be printed to stdout.\n\n```javascript\ntransport.silent();\ntransport.ls(); // output won't be printed to stdout\ntransport.verbose();\ntransport.ls(); // output will be printed to stdout\n```\n\n### transport.failsafe()\n\nWhen calling `failsafe()`, all subsequent commands are allowed to fail\nuntil `unsafe()` is called. In other words, the flight will continue\neven if the return code of the command is not `0`. This is helpful if\neither you expect a command to fail or their nature is to return a\nnon-zero exit code.\n\n```javascript\ntransport.failsafe();\ntransport.ls('foo'); // ls: foo: No such file or directory\ntransport.log('Previous command failed, but flight was not aborted');\n```\n\n### transport.unsafe()\n\nCalling `unsafe()` reverts the behavior introduced with `failsafe()`.\nThe flight will be aborted if a subsequent command fails (i.e. returns\na non-zero exit code). This is the default behavior.\n\n```javascript\ntransport.failsafe();\ntransport.ls('foo'); // ls: foo: No such file or directory\ntransport.log('Previous command failed, but flight was not aborted');\ntransport.unsafe();\ntransport.ls('foo'); // ls: foo: No such file or directory\n// flight aborted\n```\n\n### transport.debug(message)\n\nPrint a debug message to stdout if debug mode is enabled. Flightplan\ntakes care that the message is formatted correctly within the current\ncontext.\n\n```javascript\ntransport.debug('Copying files to remote hosts');\n```\n\n### transport.abort([message])\n\nManually abort the current flight and prevent any further commands and\nflights from being executed. An optional message can be passed which\nis displayed after the flight has been aborted.\n\n```javascript\ntransport.abort('Severe turbulences over the atlantic ocean!');\n```\n\n<!-- End lib/transport/index.js -->\n\n<!-- ENDDOCS -->\n\n[npm-url]: https://npmjs.org/package/flightplan\n[npm-image]: https://badge.fury.io/js/flightplan.png",
  "_id": "flightplan@0.4.0",
  "_from": "flightplan@*"
}
